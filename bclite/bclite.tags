	Session.vim	/^vnoremap  "+y$/;"	m
	Session.vim	/^inoremap  :w$/;"	m
	Session.vim	/^inoremap  "+gP$/;"	m
	Session.vim	/^vnoremap  "+gP$/;"	m
	Session.vim	/^inoremap <expr>  omni#cpp#maycomplete#Complete()$/;"	m
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
.	Session.vim	/^inoremap <expr> . omni#cpp#maycomplete#Dot()$/;"	m
0	Session.vim	/^normal! 0$/;"	m
011l	Session.vim	/^normal! 011l$/;"	m
02l	Session.vim	/^normal! 02l$/;"	m
066l	Session.vim	/^normal! 066l$/;"	m
:	Session.vim	/^inoremap <expr> : omni#cpp#maycomplete#Scope()$/;"	m
<F2>	Session.vim	/^inoremap <F2> $/;"	m
<Plug>NetrwBrowseX	Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)$/;"	m
<S-Insert>	Session.vim	/^map <S-Insert> <MiddleMouse>$/;"	m
<S-Insert>	Session.vim	/^map! <S-Insert> <MiddleMouse>$/;"	m
>	Session.vim	/^inoremap <expr> > omni#cpp#maycomplete#Arrow()$/;"	m
CC	Makefile	/^CC=gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS=-Wall -ggdb$/;"	m
COLLISION_RATE	hash.c	12;"	d	file:
COMMON_H_	common.h	2;"	d
CRLF	macros.h	16;"	d
FALSE	macros.h	5;"	d
FREE	macros.h	53;"	d
HASH_H_	hash.h	2;"	d
HASH_SIZE	hash.c	10;"	d	file:
INITIAL_SZ	id_table.c	12;"	d	file:
LEX_MAIN	Makefile	/^LEX_MAIN = lex_test.o$/;"	m
LEX_OBJS	Makefile	/^LEX_OBJS = helper_funcs.o lex.o id_table.o hash.o primes.o$/;"	m
LEX_TEST	Makefile	/^LEX_TEST = lex_test$/;"	m
MACROS_H_	macros.h	2;"	d
NULL	macros.h	13;"	d
PRIMES_H_	primes.h	2;"	d
PRIM_NUM	primes.c	7;"	d	file:
RELOP_GE	lex.h	/^	RELOP_GE,$/;"	e	enum:__anon4
RELOP_GR	lex.h	/^	RELOP_GR,$/;"	e	enum:__anon4
RELOP_LE	lex.h	/^	RELOP_LE,$/;"	e	enum:__anon4
RELOP_LO	lex.h	/^	RELOP_LO,$/;"	e	enum:__anon4
SHOULDNT_REACH	macros.h	20;"	d
STREQ	macros.h	18;"	d
SYN_TREE	syn_tree.h	4;"	d
SYN_TREE_AS	syn_tree.h	/^	SYN_TREE_AS,$/;"	e	enum:__anon6
SYN_TREE_EXPR	syn_tree.h	/^	SYN_TREE_EXPR,$/;"	e	enum:__anon6
SYN_TREE_ID	syn_tree.h	/^	SYN_TREE_ID,$/;"	e	enum:__anon6
SYN_TREE_NUM	syn_tree.h	/^	SYN_TREE_NUM,$/;"	e	enum:__anon6
SYN_TREE_UNKNOWN	syn_tree.h	/^	SYN_TREE_UNKNOWN,$/;"	e	enum:__anon6
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
TOK_AS	lex.h	/^	TOK_AS,$/;"	e	enum:__anon3
TOK_DIV	lex.h	/^	TOK_DIV,$/;"	e	enum:__anon3
TOK_EOL	lex.h	/^	TOK_EOL,$/;"	e	enum:__anon3
TOK_ID	lex.h	/^	TOK_ID,$/;"	e	enum:__anon3
TOK_LPAR	lex.h	/^	TOK_LPAR,$/;"	e	enum:__anon3
TOK_MINUS	lex.h	/^	TOK_MINUS,$/;"	e	enum:__anon3
TOK_MUL	lex.h	/^	TOK_MUL,$/;"	e	enum:__anon3
TOK_NUM	lex.h	/^	TOK_NUM,$/;"	e	enum:__anon3
TOK_PLUS	lex.h	/^	TOK_PLUS,$/;"	e	enum:__anon3
TOK_RELOP	lex.h	/^	TOK_RELOP,$/;"	e	enum:__anon3
TOK_RPAR	lex.h	/^	TOK_RPAR,$/;"	e	enum:__anon3
TOK_UNKNOWN	lex.h	/^	TOK_UNKNOWN,$/;"	e	enum:__anon3
TRAVERSE_MAIN	Makefile	/^TRAVERSE_MAIN = traverse_test.o$/;"	m
TRAVERSE_OBJS	Makefile	/^TRAVERSE_OBJS = stack.o syntax.o syn_tree.o traverse.o $/;"	m
TRAVERSE_TEST	Makefile	/^TRAVERSE_TEST = traverse_test$/;"	m
TRUE	macros.h	9;"	d
WARN	hash.c	14;"	d	file:
_HELPER_H_	helper_funcs.h	2;"	d
_ID_TABLE_H_	id_table.h	2;"	d
_STACK_H_	stack.h	2;"	d
_SYNTAX_H_	syntax.h	2;"	d
_SYN_TREE_H_	syn_tree.h	2;"	d
_TRAVERSE_H_	traverse.h	2;"	d
__LEX_H__	lex.h	2;"	d
_hash_table_insert	hash.c	/^_hash_table_insert(struct hash_table *table, void *key, void *data)$/;"	f	file:
arr	hash.c	/^	struct hash_bucket *arr;$/;"	m	struct:hash_table	typeref:struct:hash_table::hash_bucket	file:
boolean_t	common.h	/^typedef int boolean_t;$/;"	t
bucket	hash.c	/^	struct hash_bucket *bucket;$/;"	m	struct:hash_table_iter	typeref:struct:hash_table_iter::hash_bucket	file:
callback	traverse.c	/^	traverse_cb callback;$/;"	m	struct:__anon11	file:
cmp_cb	hash.c	/^	hash_compare_t	cmp_cb;$/;"	m	struct:hash_table	file:
collision	hash.c	/^	size_t		collision;$/;"	m	struct:hash_table	file:
count	hash.c	/^	size_t		count;$/;"	m	struct:hash_table	file:
current_tok	syntax.c	/^static tok_t current_tok;$/;"	v	file:
data	hash.c	/^	void		*data;$/;"	m	struct:hash_bucket	file:
default_hash_cb	hash.c	/^default_hash_cb(const void *ptr)$/;"	f	file:
default_key_cmp_cb	hash.c	/^default_key_cmp_cb(const void *a, const void *b)$/;"	f	file:
destructor	syn_tree.h	/^	destructor_t destructor;$/;"	m	struct:syn_tree
destructor_t	syn_tree.h	/^typedef void (*destructor_t)(struct syn_tree *p);$/;"	t
error	macros.h	60;"	d
expr	syntax.c	/^expr()$/;"	f
expr_rest	syntax.c	/^expr_rest(syn_tree_t *left)$/;"	f
factor	syntax.c	/^factor()$/;"	f
get_next_token	lex.c	/^get_next_token()$/;"	f
gx	Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
hash_bucket	hash.c	/^struct hash_bucket {$/;"	s	file:
hash_callback_t	hash.h	/^typedef unsigned long (*hash_callback_t)(const void *data);$/;"	t
hash_cb	hash.c	/^	hash_callback_t	hash_cb;$/;"	m	struct:hash_table	file:
hash_compare_t	hash.h	/^typedef int (*hash_compare_t)(const void *a, const void *b);$/;"	t
hash_table	hash.c	/^struct hash_table {$/;"	s	file:
hash_table_clean	hash.c	/^hash_table_clean(struct hash_table *table)$/;"	f
hash_table_destroy	hash.c	/^hash_table_destroy(struct hash_table **table)$/;"	f
hash_table_insert	hash.c	/^hash_table_insert(struct hash_table *table, void *key, void *data)$/;"	f
hash_table_insert_unique	hash.c	/^hash_table_insert_unique(struct hash_table *table, void *key, void *data)$/;"	f
hash_table_iter	hash.c	/^struct hash_table_iter {$/;"	s	file:
hash_table_iterate	hash.c	/^hash_table_iterate(struct hash_table_iter *iter, void **res_key, void **res_data)$/;"	f
hash_table_iterate_deinit	hash.c	/^hash_table_iterate_deinit(struct hash_table_iter **iter)$/;"	f
hash_table_iterate_init	hash.c	/^hash_table_iterate_init(struct hash_table *table)$/;"	f
hash_table_lookup	hash.c	/^hash_table_lookup(struct hash_table *table, void *key, void **res_data)$/;"	f
hash_table_new	hash.c	/^hash_table_new(size_t hint_size, hash_callback_t hash, hash_compare_t key_cmp)$/;"	f
hash_table_remove	hash.c	/^hash_table_remove(struct hash_table *table, void *key)$/;"	f
hash_table_replace	hash.c	/^hash_table_replace(struct hash_table *table, void *key, void *data)$/;"	f
id	lex.h	/^	int id;$/;"	m	struct:lex_item
id_compare	id_table.c	/^id_compare(void *a, void *b)$/;"	f	file:
id_hash_cb	id_table.c	/^id_hash_cb(const void *data)$/;"	f	file:
id_table_create	id_table.c	/^id_table_create()$/;"	f
id_table_destroy	id_table.c	/^id_table_destroy()$/;"	f
id_table_destroy_cb	id_table.c	/^id_table_destroy_cb(id_table_item_t *item)$/;"	f	file:
id_table_insert	id_table.c	/^id_table_insert(id_table_item_t *item)$/;"	f
id_table_item_t	id_table.h	/^} id_table_item_t;$/;"	t	typeref:struct:__anon2
id_table_lookup	id_table.c	/^id_table_lookup(char *name)$/;"	f
identifier	id_table.c	/^struct hash_table *identifier;$/;"	v	typeref:struct:hash_table
idx	hash.c	/^	unsigned int	idx;$/;"	m	struct:hash_table_iter	file:
item	lex.h	/^		id_table_item_t *item;$/;"	m	union:lex_item::__anon5
item	syn_tree.h	/^	id_table_item_t *item;$/;"	m	struct:__anon9
key	hash.c	/^	void		*key;$/;"	m	struct:hash_bucket	file:
left	syn_tree.h	/^	struct syn_tree *left;$/;"	m	struct:syn_tree	typeref:struct:syn_tree::syn_tree
lex_item	lex.c	/^struct lex_item lex_item;$/;"	v	typeref:struct:lex_item
lex_item	lex.h	/^struct lex_item {$/;"	s
lex_item_prev	syntax.c	/^static struct lex_item lex_item_prev;$/;"	v	typeref:struct:lex_item	file:
lst	stack.c	/^struct lst {$/;"	s	file:
main	lex_test.c	/^main()$/;"	f
main	traverse_test.c	/^main(int argc, char *argv[])$/;"	f
malloc_or_die	helper_funcs.c	/^malloc_or_die(size_t sz)$/;"	f
match	syntax.c	/^match(tok_t expect)$/;"	f	file:
name	id_table.h	/^	char *name;$/;"	m	struct:__anon2
nerrors	syntax.c	/^static int nerrors;$/;"	v	file:
next	hash.c	/^	struct hash_bucket *next;$/;"	m	struct:hash_bucket	typeref:struct:hash_bucket::hash_bucket	file:
next	stack.c	/^	struct lst *next;$/;"	m	struct:lst	typeref:struct:lst::lst	file:
node	traverse.c	/^	syn_tree_node_t node;$/;"	m	struct:__anon11	file:
node_type	traverse.c	/^} node_type [] = {$/;"	v	typeref:struct:__anon11
num	lex.h	/^		int num;$/;"	m	union:lex_item::__anon5
num	syn_tree.h	/^	int num;$/;"	m	struct:__anon8
op	lex.h	/^		int op;$/;"	m	union:lex_item::__anon5
opcode	syn_tree.h	/^	int opcode;$/;"	m	struct:__anon7
prime_nearest	primes.c	/^unsigned int prime_nearest(size_t size)$/;"	f
prime_numbers	primes.c	/^static const unsigned int prime_numbers[] = {$/;"	v	file:
print_result	traverse.c	/^print_result()$/;"	f
print_tok	syntax.c	/^print_tok()$/;"	f
print_usage	helper_funcs.c	/^print_usage(char *pname)$/;"	f
print_warn	helper_funcs.c	/^print_warn(char *str)$/;"	f
print_warn_and_die	helper_funcs.c	/^print_warn_and_die(char *str)$/;"	f
program_start	syntax.c	/^program_start()$/;"	f
relop_t	lex.h	/^} relop_t;$/;"	t	typeref:enum:__anon4
ret_entry_exists	common.h	/^	ret_entry_exists  = -5,$/;"	e	enum:__anon1
ret_err	common.h	/^        ret_err           = -1,$/;"	e	enum:__anon1
ret_file_exists	common.h	/^        ret_file_exists   = 1,$/;"	e	enum:__anon1
ret_invalid	common.h	/^        ret_invalid       = -2,$/;"	e	enum:__anon1
ret_no_access	common.h	/^        ret_no_access     = -4,$/;"	e	enum:__anon1
ret_not_file	common.h	/^        ret_not_file      = 2,$/;"	e	enum:__anon1
ret_not_found	common.h	/^	ret_not_found     = -6,	$/;"	e	enum:__anon1
ret_ok	common.h	/^        ret_ok            = 0,$/;"	e	enum:__anon1
ret_out_of_memory	common.h	/^        ret_out_of_memory = -3,$/;"	e	enum:__anon1
ret_t	common.h	/^} ret_t;$/;"	t	typeref:enum:__anon1
return_if_fail	macros.h	29;"	d
return_val_if_fail	macros.h	41;"	d
right	syn_tree.h	/^	struct syn_tree *right;$/;"	m	struct:syn_tree	typeref:struct:syn_tree::syn_tree
s:cpo_save	Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	Session.vim	/^let s:l = 1 - ((0 * winheight(0) + 18) \/ 36)$/;"	v
s:l	Session.vim	/^let s:l = 1 - ((0 * winheight(0) + 18) \/ 37)$/;"	v
s:l	Session.vim	/^let s:l = 101 - ((22 * winheight(0) + 18) \/ 36)$/;"	v
s:l	Session.vim	/^let s:l = 106 - ((0 * winheight(0) + 18) \/ 37)$/;"	v
s:l	Session.vim	/^let s:l = 17 - ((0 * winheight(0) + 18) \/ 37)$/;"	v
s:l	Session.vim	/^let s:l = 17 - ((16 * winheight(0) + 18) \/ 37)$/;"	v
s:l	Session.vim	/^let s:l = 182 - ((35 * winheight(0) + 18) \/ 36)$/;"	v
s:l	Session.vim	/^let s:l = 2 - ((0 * winheight(0) + 18) \/ 36)$/;"	v
s:l	Session.vim	/^let s:l = 2 - ((1 * winheight(0) + 18) \/ 37)$/;"	v
s:l	Session.vim	/^let s:l = 3 - ((0 * winheight(0) + 18) \/ 36)$/;"	v
s:l	Session.vim	/^let s:l = 36 - ((35 * winheight(0) + 18) \/ 36)$/;"	v
s:l	Session.vim	/^let s:l = 4 - ((0 * winheight(0) + 18) \/ 37)$/;"	v
s:l	Session.vim	/^let s:l = 55 - ((0 * winheight(0) + 18) \/ 36)$/;"	v
s:l	Session.vim	/^let s:l = 78 - ((0 * winheight(0) + 18) \/ 36)$/;"	v
s:l	Session.vim	/^let s:l = 8 - ((7 * winheight(0) + 18) \/ 36)$/;"	v
s:l	Session.vim	/^let s:l = 95 - ((0 * winheight(0) + 18) \/ 37)$/;"	v
s:l	Session.vim	/^let s:l = 98 - ((0 * winheight(0) + 18) \/ 36)$/;"	v
s:so_save	Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
size	hash.c	/^	size_t		size;$/;"	m	struct:hash_table	file:
stack	stack.c	/^struct lst *stack = NULL;$/;"	v	typeref:struct:lst
stack_flush	stack.c	/^stack_flush()$/;"	f
stack_pop	stack.c	/^stack_pop()$/;"	f
stack_push	stack.c	/^stack_push(int val)$/;"	f
statesment	syntax.c	/^statesment()$/;"	f
syn_tree	syn_tree.h	/^typedef struct syn_tree {$/;"	s
syn_tree_as_free	syn_tree.c	/^syn_tree_as_free(syn_tree_t *tree)$/;"	f	file:
syn_tree_as_new	syn_tree.c	/^syn_tree_as_new(syn_tree_t *left, syn_tree_t *right)$/;"	f
syn_tree_as_t	syn_tree.h	/^} syn_tree_as_t;$/;"	t	typeref:struct:__anon10
syn_tree_id_free	syn_tree.c	/^syn_tree_id_free(syn_tree_t *tree)$/;"	f	file:
syn_tree_id_new	syn_tree.c	/^syn_tree_id_new(id_table_item_t *item)$/;"	f
syn_tree_id_t	syn_tree.h	/^} syn_tree_id_t;$/;"	t	typeref:struct:__anon9
syn_tree_node_t	syn_tree.h	/^} syn_tree_node_t;$/;"	t	typeref:enum:__anon6
syn_tree_num_free	syn_tree.c	/^syn_tree_num_free(syn_tree_t *tree)$/;"	f	file:
syn_tree_num_new	syn_tree.c	/^syn_tree_num_new(int num)$/;"	f
syn_tree_num_t	syn_tree.h	/^} syn_tree_num_t;$/;"	t	typeref:struct:__anon8
syn_tree_op_free	syn_tree.c	/^syn_tree_op_free(syn_tree_t *tree)$/;"	f	file:
syn_tree_op_new	syn_tree.c	/^syn_tree_op_new(syn_tree_t *left, syn_tree_t *right,int opcode)$/;"	f
syn_tree_op_t	syn_tree.h	/^} syn_tree_op_t;$/;"	t	typeref:struct:__anon7
syn_tree_t	syn_tree.h	/^} syn_tree_t;	$/;"	t	typeref:struct:syn_tree
syn_tree_unref	syn_tree.c	/^syn_tree_unref(syn_tree_t *tree)$/;"	f
table	hash.c	/^	struct hash_table *table;$/;"	m	struct:hash_table_iter	typeref:struct:hash_table_iter::hash_table	file:
term	syntax.c	/^term()$/;"	f
term_rest	syntax.c	/^term_rest(syn_tree_t *left)$/;"	f
tok_names	syntax.c	/^char *tok_names[] = {$/;"	v
tok_next	syntax.c	/^tok_next()$/;"	f	file:
tok_t	lex.h	/^} tok_t;$/;"	t	typeref:enum:__anon3
tokens	lex_test.c	/^char *tokens[] = {"TOK_ID",$/;"	v
traverse	traverse.c	/^traverse(syn_tree_t *tree)$/;"	f
traverse_as	traverse.c	/^traverse_as(syn_tree_t *tree)$/;"	f	file:
traverse_cb	traverse.c	/^typedef void (*traverse_cb)(syn_tree_t *tree);$/;"	t	file:
traverse_expr	traverse.c	/^traverse_expr(syn_tree_t *tree)$/;"	f	file:
traverse_id	traverse.c	/^traverse_id(syn_tree_t *tree)$/;"	f	file:
traverse_num	traverse.c	/^traverse_num(syn_tree_t *tree)$/;"	f	file:
tree	syn_tree.h	/^	syn_tree_t tree;$/;"	m	struct:__anon10
tree	syn_tree.h	/^	syn_tree_t tree;$/;"	m	struct:__anon7
tree	syn_tree.h	/^	syn_tree_t tree;$/;"	m	struct:__anon8
tree	syn_tree.h	/^	syn_tree_t tree;$/;"	m	struct:__anon9
type	syn_tree.h	/^	int type;$/;"	m	struct:syn_tree
update_prev_token	syntax.c	/^update_prev_token()$/;"	f	file:
val	stack.c	/^	int val;$/;"	m	struct:lst	file:
value	id_table.h	/^	int value;$/;"	m	struct:__anon2
warning	macros.h	72;"	d
zt	Session.vim	/^normal! zt$/;"	m
